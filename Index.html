<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü–æ—é—â–∞—è –ù–µ–π—Ä–æ—Å–µ—Ç—å (–§–∏–Ω–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>
    <link rel="stylesheet" href="https://jen9-ops.github.io/library/style.css">
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #f8f9fa; color: #333; }
        .main-container { max-width: 600px; margin: auto; padding: 15px; }
        h1, h3 { text-align: center; }
        button { display: block; width: 100%; padding: 12px; margin-bottom: 10px; font-size: 16px; font-weight: bold; border: none; border-radius: 8px; color: white; cursor: pointer; transition: background-color 0.2s, transform 0.1s; }
        button:active { transform: scale(0.98); }
        #openVisualizerButton, #clearCanvasButton { background-color: #9c27b0; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        .playback-controls { display: flex; gap: 10px; }
        pre { background-color: #ffffff; padding: 10px; border-radius: 5px; white-space: pre-wrap; word-wrap: break-word; max-height: 250px; overflow-y: auto; border: 1px solid #e0e0e0; font-family: "Courier New", Courier, monospace; }
        #visualizer-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #1a1a1a; z-index: 1000; display: none; }
        #music-canvas { display: block; width: 100%; height: 100%; }
        #close-visualizer-button { position: absolute; top: 20px; right: 20px; width: auto; padding: 10px 20px; background-color: #ffffff; color: #1a1a1a; z-index: 1001; }
        #status-container { text-align: center; padding: 10px; border-radius: 8px; margin-bottom: 10px; transition: background-color 0.3s; }
        .status-info { background-color: #e9ecef; }
        .status-success { background-color: #d4edda; color: #155724; }
        .status-error { background-color: #f8d7da; color: #721c24; }
    </style>
</head>
<body>

    <div class="main-container">
        <h1>–ü–æ—é—â–∞—è –ù–µ–π—Ä–æ—Å–µ—Ç—å üé§</h1>
        
        <div id="auth-block">
            <button id="signin-button" style="background-color: #db4437;">–í–æ–π—Ç–∏ —á–µ—Ä–µ–∑ Google</button>
            <button id="signout-button" style="background-color: #6c757d; display: none;">–í—ã–π—Ç–∏</button>
        </div>
        <div class="button-group">
            <h3>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è</h3>
            <button id="openVisualizerButton">üé® –û—Ç–∫—Ä—ã—Ç—å –≤–∏–∑—É–∞–ª–∏–∑–∞—Ç–æ—Ä</button>
            <button id="clearCanvasButton">üßπ –û—á–∏—Å—Ç–∏—Ç—å —Ö–æ–ª—Å—Ç</button>
        </div>
        <div class="action-group">
            <p id="data-info" style="text-align:center;">–ü–∞—Ä "–Ω–æ—Ç–∞-—Å–ª–æ–≥" –≤ –±–∞–∑–µ: <b id="data-size">0</b></p>
            <button id="trainButton">1. –û–±—É—á–∏—Ç—å –º–æ–¥–µ–ª—å</button>
            <button id="generateButton" disabled>2. –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–µ—Å–Ω—é</button>
        </div>
        <h3>–°—Ç–∞—Ç—É—Å</h3>
        <div id="status-container" class="status-info"><p id="status-text">–í–æ–π–¥–∏—Ç–µ –≤ Google –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏.</p><p id="model-info" style="font-weight: bold;"></p></div>
        <progress id="training-progress" value="0" max="100" style="display: none; width:100%;"></progress>
        <h3>–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–µ—Å–Ω—è:</h3>
        <pre id="output">–ó–¥–µ—Å—å –ø–æ—è–≤–∏—Ç—Å—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç...</pre>
        <div class="playback-controls">
            <button id="playButton" class="playback-button" disabled>‚ñ∂Ô∏è –ü—Ä–æ—Å–ª—É—à–∞—Ç—å</button>
            <button id="stopButton" class="playback-button" disabled>‚èπÔ∏è –°—Ç–æ–ø</button>
        </div>
        <div class="button-group">
            <h3>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–æ–¥–µ–ª—å—é</h3>
            <button id="saveModelButton" class="manage-button" disabled>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞ Google –î–∏—Å–∫</button>
        </div>
    </div>

    <div id="visualizer-overlay">
        <canvas id="music-canvas"></canvas>
        <button id="close-visualizer-button">–ó–∞–∫—Ä—ã—Ç—å</button>
    </div>

    <script>
        // --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø GOOGLE API ---
        // ‚¨áÔ∏è ‚¨áÔ∏è ‚¨áÔ∏è –í–ê–ñ–ù–û: –í–°–¢–ê–í–¨–¢–ï –í–ê–®–ò –ö–õ–Æ–ß–ò –¢–û–õ–¨–ö–û –°–Æ–î–ê ‚¨áÔ∏è ‚¨áÔ∏è ‚¨áÔ∏è
        const CLIENT_ID ='1007270447390-egcom4kdajo64mh6n4gdf9vmbmoivmrs.apps.googleusercontent.com';
        const API_KEY = '–í–ê–®_API_KEY';
        // ‚¨ÜÔ∏è ‚¨ÜÔ∏è ‚¨ÜÔ∏è –ë–û–õ–¨–®–ï –ù–ò–ß–ï–ì–û –ú–ï–ù–Ø–¢–¨ –ù–ï –ù–£–ñ–ù–û ‚¨ÜÔ∏è ‚¨ÜÔ∏è ‚¨ÜÔ∏è
        
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        const SCOPES = 'https://www.googleapis.com/auth/drive.file';
        const MODEL_FILE_NAME = 'singing_model.ai';

        const songData = [
            {note: 60, lyric: 'Twink'}, {note: 60, lyric: 'le'}, {note: 67, lyric: 'Twink'}, {note: 67, lyric: 'le'},
            {note: 69, lyric: 'Lit'}, {note: 69, lyric: 'tle'}, {note: 67, lyric: 'Star'}, {note: 0, lyric: ' '},
            {note: 65, lyric: 'How'}, {note: 65, lyric: 'I'}, {note: 64, lyric: 'Won'}, {note: 64, lyric: 'der'},
            {note: 62, lyric: 'What'}, {note: 62, lyric: 'You'}, {note: 60, lyric: 'Are'}, {note: 0, lyric: ' '}
        ];

        let model, lastGeneratedSong = [], combinedData = [...songData];
        let reshapedXs, ys, tokenToIndex, indexToToken, vocabSize, sequences;
        let synth, currentSequence;
        const utterance = new SpeechSynthesisUtterance();
        utterance.lang = 'en-US';
        utterance.rate = 1.5;

        const openVisualizerBtn = document.getElementById('openVisualizerButton'); const closeVisualizerBtn = document.getElementById('close-visualizer-button'); const clearCanvasBtn = document.getElementById('clearCanvasButton'); const visualizerOverlay = document.getElementById('visualizer-overlay'); const canvas = document.getElementById('music-canvas'); const ctx = canvas.getContext('2d'); const trainBtn = document.getElementById('trainButton'); const generateBtn = document.getElementById('generateButton'); const retrainBtn = document.getElementById('retrainButton'); const saveBtn = document.getElementById('saveModelButton'); const playBtn = document.getElementById('playButton'); const stopBtn = document.getElementById('stopButton'); const statusContainer = document.getElementById('status-container'); const statusTextEl = document.getElementById('status-text'); const modelInfoEl = document.getElementById('model-info'); const progressEl = document.getElementById('training-progress'); const outputEl = document.getElementById('output'); const dataSizeEl = document.getElementById('data-size');
        
        openVisualizerBtn.addEventListener('click', () => { visualizerOverlay.style.display = 'block'; setupCanvas(); });
        closeVisualizerBtn.addEventListener('click', () => { visualizerOverlay.style.display = 'none'; });
        clearCanvasBtn.addEventListener('click', () => { ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0, 0, canvas.width, canvas.height); updateStatus('–•–æ–ª—Å—Ç –æ—á–∏—â–µ–Ω.', 'info'); });
        
        function setupCanvas() { const dpr = window.devicePixelRatio || 1; canvas.width = window.innerWidth * dpr; canvas.height = window.innerHeight * dpr; ctx.scale(dpr, dpr); ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0, 0, canvas.width, canvas.height); }
        function getNoteColor(midi) { if (midi <= 0) return '#444444'; const hue = (midi % 12) * 30; return `hsl(${hue}, 90%, 65%)`; }
        function drawNoteDot(x, y, color, midi) { ctx.beginPath(); const radius = 2 + (midi / 127) * 8; ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fillStyle = color; ctx.shadowColor = color; ctx.shadowBlur = 10; ctx.globalAlpha = 0.9; ctx.fill(); ctx.shadowBlur = 0; ctx.globalAlpha = 1.0; }
        
        async function playMelody() {
            if (lastGeneratedSong.length === 0) return;
            if (Tone.context.state !== 'running') await Tone.start();
            if (!synth) synth = new Tone.Synth().toDestination();
            if (currentSequence) currentSequence.stop(0).dispose();
            const events = lastGeneratedSong.map((item, index) => ({ time: index * 0.4, noteName: Tone.Frequency(item.note, "midi").toNote(), ...item }));
            currentSequence = new Tone.Part((time, value) => {
                if (value.note > 0) synth.triggerAttackRelease(value.noteName, '8n', time);
                window.speechSynthesis.cancel(); utterance.text = value.lyric; window.speechSynthesis.speak(utterance);
                if (visualizerOverlay.style.display === 'block') { Tone.Draw.schedule(() => { const minMidi = 48, maxMidi = 84; const x = (value.index / lastGeneratedSong.length) * window.innerWidth; const y_percent = (value.note - minMidi) / (maxMidi - minMidi); const y = window.innerHeight * (1 - y_percent); drawNoteDot(x, y, getNoteColor(value.note), value.note); }, time); }
            }, events).start(0);
            Tone.Transport.start();
            playBtn.disabled = true; stopBtn.disabled = false;
        }
        
        function stopMelody() { Tone.Transport.stop().cancel(0); window.speechSynthesis.cancel(); playBtn.disabled = false; stopBtn.disabled = true; }
        
        function prepareData() {
            dataSizeEl.innerText = combinedData.length; if (reshapedXs) tf.dispose([reshapedXs, ys]);
            const tokens = combinedData.map(item => `${item.note}-${item.lyric}`); const uniqueTokens = [...new Set(tokens)];
            vocabSize = uniqueTokens.length; tokenToIndex = new Map(uniqueTokens.map((token, index) => [token, index])); indexToToken = new Map(uniqueTokens.map((token, index) => [index, token]));
            const tokenIndices = tokens.map(token => tokenToIndex.get(token)); const sequenceLength = 4; sequences = []; const nextTokenIndices = [];
            for (let i = 0; i < tokenIndices.length - sequenceLength; i++) { sequences.push(tokenIndices.slice(i, i + sequenceLength)); nextTokenIndices.push(tokenIndices[i + sequenceLength]); }
            const xs = tf.tensor2d(sequences, [sequences.length, sequenceLength]); ys = tf.oneHot(tf.tensor1d(nextTokenIndices, 'int32'), vocabSize);
            const normalizedXs = xs.div(tf.scalar(vocabSize)); reshapedXs = normalizedXs.reshape([sequences.length, sequenceLength, 1]); tf.dispose([xs, normalizedXs]);
        }
        
        async function generateMusic() {
            if (!model) return; outputEl.innerText = '–ì–µ–Ω–µ—Ä–∞—Ü–∏—è... üé§'; let currentSequence = sequences[Math.floor(Math.random() * sequences.length)]; let generatedSong = [];
            for (let i = 0; i < 40; i++) {
                const prediction = tf.tidy(() => { const inputTensor = tf.tensor1d(currentSequence).div(tf.scalar(vocabSize)).reshape([1, sequenceLength, 1]); return model.predict(inputTensor); });
                const predictedIndex = tf.multinomial(prediction, 1).dataSync()[0]; const tokenStr = indexToToken.get(predictedIndex);
                const [noteStr, lyric] = tokenStr.split('-'); const note = parseInt(noteStr, 10);
                generatedSong.push({ note, lyric });
                currentSequence = [...currentSequence.slice(1), predictedIndex]; tf.dispose(prediction);
            }
            outputEl.innerText = JSON.stringify(generatedSong, null, 2); lastGeneratedSong = generatedSong; playBtn.disabled = false;
        }
        
        let tokenClient, gapiInited = false, gisInited = false;
        document.getElementById('signin-button').style.visibility = 'hidden'; document.getElementById('signout-button').style.visibility = 'hidden';
        function gapiLoaded() { gapi.load('client', initializeGapiClient); }
        async function initializeGapiClient() { await gapi.client.init({ apiKey: API_KEY, discoveryDocs: [DISCOVERY_DOC] }); gapiInited = true; maybeEnableButtons(); }
        function gisLoaded() { tokenClient = google.accounts.oauth2.initTokenClient({ client_id: CLIENT_ID, scope: SCOPES, callback: '' }); gisInited = true; maybeEnableButtons(); }
        function maybeEnableButtons() { if (gapiInited && gisInited) document.getElementById('signin-button').style.visibility = 'visible'; }
        
        const signinBtn = document.getElementById('signin-button'); const signoutBtn = document.getElementById('signout-button');
        signinBtn.addEventListener('click', () => { tokenClient.callback = async (resp) => { if (resp.error !== undefined) { throw (resp); } signinBtn.style.display = 'none'; signoutBtn.style.display = 'block'; await loadFromDrive(); }; if (gapi.client.getToken() === null) tokenClient.requestAccessToken({prompt: 'consent'}); else tokenClient.requestAccessToken({prompt: ''}); });
        signoutBtn.addEventListener('click', () => { const token = gapi.client.getToken(); if (token !== null) { google.accounts.oauth2.revoke(token.access_token); gapi.client.setToken(''); } signinBtn.style.display = 'block'; signoutBtn.style.display = 'none'; updateStatus('–í—ã –≤—ã—à–ª–∏ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞.'); });
        
        let modelFileId = null;
        async function saveToDrive() { if (!model) return; updateStatus('–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∞ Google –î–∏—Å–∫...', 'info'); const savedModel = await model.save(tf.io.withSaveHandler(async (artifacts) => artifacts)); const modelData = { modelTopology: savedModel.modelTopology, weightSpecs: savedModel.weightSpecs, weightData: Array.from(new Uint8Array(savedModel.weightData)), }; const modelString = JSON.stringify(modelData); const fileMetadata = { 'name': MODEL_FILE_NAME, 'mimeType': 'application/json' }; const requestBody = new FormData(); requestBody.append('metadata', new Blob([JSON.stringify(fileMetadata)], { type: 'application/json' })); requestBody.append('file', new Blob([modelString], { type: 'application/json' })); let request; if (modelFileId) request = gapi.client.request({ path: `/upload/drive/v3/files/${modelFileId}`, method: 'PATCH', params: { uploadType: 'multipart' }, body: requestBody }); else request = gapi.client.request({ path: '/upload/drive/v3/files', method: 'POST', params: { uploadType: 'multipart' }, body: requestBody }); const response = await request; modelFileId = response.result.id; updateStatus('–ú–æ–¥–µ–ª—å —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!', 'success'); }
        async function loadFromDrive() { updateStatus('–ü–æ–∏—Å–∫ –º–æ–¥–µ–ª–∏ –Ω–∞ Google –î–∏—Å–∫–µ...', 'info'); const response = await gapi.client.drive.files.list({ q: `name='${MODEL_FILE_NAME}' and trashed=false`, spaces: 'drive', fields: 'files(id, name)' }); if (response.result.files.length === 0) { updateStatus('–ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –û–±—É—á–∏—Ç–µ –Ω–æ–≤—É—é.', 'info'); trainBtn.disabled = false; return; } modelFileId = response.result.files[0].id; updateStatus('–ú–æ–¥–µ–ª—å –Ω–∞–π–¥–µ–Ω–∞! –ó–∞–≥—Ä—É–∑–∫–∞...', 'info'); const fileContentResponse = await gapi.client.drive.files.get({ fileId: modelFileId, alt: 'media' }); const modelData = fileContentResponse.result; const modelArtifacts = { modelTopology: modelData.modelTopology, weightSpecs: modelData.weightSpecs, weightData: new Uint8Array(modelData.weightData).buffer, }; model = await tf.loadLayersModel(tf.io.fromMemory(modelArtifacts)); updateStatus('–ú–æ–¥–µ–ª—å —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–∞ —Å –î–∏—Å–∫–∞!', 'success'); [generateBtn, saveBtn, trainBtn].forEach(b => b.disabled = false); }
        
        function updateStatus(message, type = 'info', modelInfo = '') { statusTextEl.innerText = message; statusContainer.className = `status-${type}`; if (modelInfo) modelInfoEl.innerText = modelInfo; }
        function createModel() { model = tf.sequential(); model.add(tf.layers.lstm({ units: 128, inputShape: [reshapedXs.shape[1], 1], returnSequences: true })); model.add(tf.layers.dropout({ rate: 0.2 })); model.add(tf.layers.lstm({ units: 128 })); model.add(tf.layers.dense({ units: vocabSize, activation: 'softmax' })); model.compile({ optimizer: 'adam', loss: 'categoricalCrossentropy', metrics: ['accuracy'] }); }
        async function trainModel() { updateStatus(`–û–±—É—á–µ–Ω–∏–µ...`, 'info'); modelInfoEl.innerText = ''; progressEl.style.display = 'block'; progressEl.value = 0; [trainBtn, generateBtn, retrainBtn, saveBtn].forEach(b => b.disabled = true); await model.fit(reshapedXs, ys, { epochs: 300, batchSize: 32, callbacks: { onEpochEnd: (epoch, logs) => { const progress = ((epoch + 1) / 300) * 100; progressEl.value = progress; updateStatus(`–ò–¥–µ—Ç –æ–±—É—á–µ–Ω–∏–µ... –≠–ø–æ—Ö–∞ ${epoch + 1}/300`, 'info'); }} }); updateStatus('–û–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!', 'success'); setTimeout(() => { progressEl.style.display = 'none'; }, 2000); [trainBtn, generateBtn, saveBtn].forEach(b => b.disabled = false); }
        
        trainBtn.addEventListener('click', async () => { if (!model) createModel(); await trainModel(); });
        generateBtn.addEventListener('click', generateMusic);
        playBtn.addEventListener('click', playMelody);
        stopBtn.addEventListener('click', stopMelody);
        saveBtn.addEventListener('click', saveToDrive);

        function init(){prepareData();}
        init();

    </script>
    <script src="https://jen9-ops.github.io/library/script.js"></script>
</body>
</html>
